# let 声明的使用
----------------
在ES6语法中新增的 **let**  主要用于代码块里面的使用，在以前的**JavaScript中，没有模块这个说法**。可能我们有时候调用变量不注意就会调用了外部的变量，而新增的**let**充分的解决了这一问题的存在。

> 请注意看下面这个例子
```javascript
    for (var i = 0; i < 5; i++) {
         console.log(i)  // 0 1,2,3,4
    }
    console.log(i)  // 5
```
在这个例子中var 是全局的变量， 在外部也可以进行访问，这就是我们在第一句话里面说的 **JavaScript没有模块化这一说法**。而**let**就解决了这个问题。
```javascript
      for (let i = 0; i < 5; i++) {
             console.log(i)  // 0 1,2,3,4
        }
        console.log(i)  // i is not defined
```
--------------------------

> 同时**let** 也解决了变量提升所带来的问题。

原来在面试中，遇见过变量提升的问题，所以也比较深刻吧。在**JavaScript**中，函数及变量声明都将被提升到函数的最顶部，全局的话也会提升到全局的最顶部。这里请看 [变量声明提升和函数声明提升](https://github.com/liu33286821/ES6/blob/master/%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87.md) 。

## 不存在变量提升 暂时性死区

在[变量声明提升和函数声明提升](https://github.com/liu33286821/ES6/blob/master/%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87.md) 这篇文章中我们也介绍到了**声明提升**的问题，ES6中```let```和```const```改变了语法的行为，使用方法必须要在声明之后否则就会报错。

##不允许重复声明

可能在ES6之前，我们使用方法不恰当会造成重复的声明。但是在```let和const```中不允许重复声明，否则就会报错。假如用了```var```在后面使用```let```同样也会报错。函数内部的参数，同样也不允许和```let```和```const```设置相同的名字，一样会进行报错。


## ES6 为什么要设置块级作用域？

> 在ES6之前，我们经常用```var```来进行声明，这样会造成一些不合理的场景。

    > * 1. 内层变量可能会覆盖外层的变量。
```
        var tmp = new Date();
        function f() {
          console.log(tmp);
          if (false) {
            var tmp = 'hello world';
          }
        }
        f(); // undefined
```
    上面这个例子我是按照书上的ES6来进行编写的。
    输出undefined的原因就在于 我们提出来的这个问题。 在ES6之前JavaScript没有块级作用域这个概念一说,所以if语句执行的时候，变量也得到了提升。
    所以才会输出undefined。

    > * 2.循环变量
    在原先的JavaScript当中，我们都经常使用var来声明，这样造成的一个后果就是for循环完毕之后，我们声明的这个变量仍然存在，并且可以调用，造成了泄漏，变成了全局变量。
